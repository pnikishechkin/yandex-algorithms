package ru.nikishechkin.yandex_algorithms.lesson_2.f_fortune_wheel;

import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;

/**
 * Развлекательный телеканал транслирует шоу «Колесо Фортуны». В процессе игры участники шоу крутят большое колесо,
 * разделенное на сектора. В каждом секторе этого колеса записано число. После того как колесо останавливается,
 * специальная стрелка указывает на один из секторов. Число в этом секторе определяет выигрыш игрока.
 *
 * Юный участник шоу заметил, что колесо в процессе вращения замедляется из-за того, что стрелка задевает за выступы
 * на колесе, находящиеся между секторами. Если колесо вращается с угловой скоростью v градусов в секунду, и стрелка,
 * переходя из сектора X к следующему сектору, задевает за очередной выступ, то текущая угловая скорость движения
 * колеса уменьшается на k градусов в секунду. При этом если v ≤ k, то колесо не может преодолеть препятствие и
 * останавливается. Стрелка в этом случае будет указывать на сектор X.
 *
 * Юный участник шоу собирается вращать колесо. Зная порядок секторов на колесе, он хочет заставить колесо вращаться
 * с такой начальной скоростью, чтобы после остановки колеса стрелка указала на как можно большее число. Колесо можно
 * вращать в любом направлении и придавать ему начальную угловую скорость от a до b градусов в секунду.
 *
 * Требуется написать программу, которая по заданному расположению чисел в секторах, минимальной и максимальной
 * начальной угловой скорости вращения колеса и величине замедления колеса при переходе через границу секторов
 * вычисляет максимальный выигрыш.
 *
 * Формат ввода
 * Первая строка входного файла содержит целое число n — количество секторов колеса (3 ≤ n ≤ 100).
 *
 * Вторая строка входного файла содержит n положительных целых чисел, каждое из которых не превышает 1000 — числа,
 * записанные в секторах колеса. Числа приведены в порядке следования секторов по часовой стрелке. Изначально стрелка
 * указывает на первое число.
 *
 * Третья строка содержит три целых числа: a, b и k (1 ≤ a ≤ b ≤ 10^9, 1 ≤ k ≤ 10^9).
 *
 * Формат вывода
 * В выходном файле должно содержаться одно целое число — максимальный выигрыш.
 */
public class FortuneWheel_v2 {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("resources\\lesson2\\inputF_10.txt")) {
            Scanner scanner = new Scanner(reader);
            // Количество секторов
            int n = scanner.nextInt();
            int[] mas = new int[n];
            int max = -1;
            for (int i = 0; i < n; i++) {
                mas[i] = scanner.nextInt();
                if (i == 0 || (mas[i] > max)) max = mas[i];
            }
            // Минимальная угловая скорость
            int a = scanner.nextInt();
            // Максимальная угловая скорость
            int b = scanner.nextInt();
            // Величина замедления колеса
            int k = scanner.nextInt();

            int countSectors = 0;
            int maxRes = -1;
            int res = -1;
            int i = a;

            // Для каждой величины угловой скорости рассчитываем конечное число на колесе
            while (i <= b) {
                // Количество переходов по секторам
                countSectors = i / k;
                // Если делится без остатка, то корректируем количество переходов
                if (i % k == 0) countSectors--;
                int ost = countSectors % n;

                int indexCW = ost;
                int indexCCW = n - ost;

                // System.out.println(i + " | Секторов: " + countSectors + " | indexCW: " + indexCW + " | indexCCW: " + indexCCW);

                if (indexCW < 0) indexCW = n + indexCCW;
                if (indexCCW >= n) indexCCW = 0;

                if (mas[indexCW] > maxRes) maxRes = mas[indexCW];
                if (mas[indexCCW] > maxRes) maxRes = mas[indexCCW];

                i = (countSectors + 1) * k + 1;

                if (maxRes == max) break;
            }
            System.out.println(maxRes);

        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
    }
}

/*
n = 5
0 1 2 3 4
5 4 3 2 1

8 7 6 5 4
3 2 1

8 1

Переходов: 7
Остаток от деления: 7 % 5 = 2

По часовой: Переходов
Против часовой: n - Переходов
 */